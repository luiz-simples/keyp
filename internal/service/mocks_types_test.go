// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/types.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/types.go -destination=internal/service/mocks_types_test.go -package=service_test
//

// Package service_test is a generated GoMock package.
package service_test

import (
	context "context"
	reflect "reflect"

	domain "github.com/luiz-simples/keyp.git/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockPersister is a mock of Persister interface.
type MockPersister struct {
	ctrl     *gomock.Controller
	recorder *MockPersisterMockRecorder
	isgomock struct{}
}

// MockPersisterMockRecorder is the mock recorder for MockPersister.
type MockPersisterMockRecorder struct {
	mock *MockPersister
}

// NewMockPersister creates a new mock instance.
func NewMockPersister(ctrl *gomock.Controller) *MockPersister {
	mock := &MockPersister{ctrl: ctrl}
	mock.recorder = &MockPersisterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPersister) EXPECT() *MockPersisterMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockPersister) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockPersisterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPersister)(nil).Close))
}

// Del mocks base method.
func (m *MockPersister) Del(arg0 context.Context, arg1 ...[]byte) (uint32, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Del", varargs...)
	ret0, _ := ret[0].(uint32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Del indicates an expected call of Del.
func (mr *MockPersisterMockRecorder) Del(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockPersister)(nil).Del), varargs...)
}

// Exists mocks base method.
func (m *MockPersister) Exists(arg0 context.Context, arg1 []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockPersisterMockRecorder) Exists(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockPersister)(nil).Exists), arg0, arg1)
}

// Expire mocks base method.
func (m *MockPersister) Expire(arg0 context.Context, arg1 []byte, arg2 uint32) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Expire", arg0, arg1, arg2)
}

// Expire indicates an expected call of Expire.
func (mr *MockPersisterMockRecorder) Expire(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expire", reflect.TypeOf((*MockPersister)(nil).Expire), arg0, arg1, arg2)
}

// Get mocks base method.
func (m *MockPersister) Get(arg0 context.Context, arg1 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockPersisterMockRecorder) Get(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPersister)(nil).Get), arg0, arg1)
}

// LIndex mocks base method.
func (m *MockPersister) LIndex(arg0 context.Context, arg1 []byte, arg2 int64) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LIndex", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LIndex indicates an expected call of LIndex.
func (mr *MockPersisterMockRecorder) LIndex(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LIndex", reflect.TypeOf((*MockPersister)(nil).LIndex), arg0, arg1, arg2)
}

// LLen mocks base method.
func (m *MockPersister) LLen(arg0 context.Context, arg1 []byte) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LLen", arg0, arg1)
	ret0, _ := ret[0].(int64)
	return ret0
}

// LLen indicates an expected call of LLen.
func (mr *MockPersisterMockRecorder) LLen(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LLen", reflect.TypeOf((*MockPersister)(nil).LLen), arg0, arg1)
}

// LPop mocks base method.
func (m *MockPersister) LPop(arg0 context.Context, arg1 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LPop", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LPop indicates an expected call of LPop.
func (mr *MockPersisterMockRecorder) LPop(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPop", reflect.TypeOf((*MockPersister)(nil).LPop), arg0, arg1)
}

// LPush mocks base method.
func (m *MockPersister) LPush(arg0 context.Context, arg1 []byte, arg2 ...[]byte) int64 {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LPush", varargs...)
	ret0, _ := ret[0].(int64)
	return ret0
}

// LPush indicates an expected call of LPush.
func (mr *MockPersisterMockRecorder) LPush(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPush", reflect.TypeOf((*MockPersister)(nil).LPush), varargs...)
}

// LRange mocks base method.
func (m *MockPersister) LRange(arg0 context.Context, arg1 []byte, arg2, arg3 int64) ([][]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LRange", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LRange indicates an expected call of LRange.
func (mr *MockPersisterMockRecorder) LRange(arg0, arg1, arg2, arg3 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LRange", reflect.TypeOf((*MockPersister)(nil).LRange), arg0, arg1, arg2, arg3)
}

// LSet mocks base method.
func (m *MockPersister) LSet(arg0 context.Context, arg1 []byte, arg2 int64, arg3 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LSet", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// LSet indicates an expected call of LSet.
func (mr *MockPersisterMockRecorder) LSet(arg0, arg1, arg2, arg3 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LSet", reflect.TypeOf((*MockPersister)(nil).LSet), arg0, arg1, arg2, arg3)
}

// Persist mocks base method.
func (m *MockPersister) Persist(arg0 context.Context, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Persist", arg0, arg1)
}

// Persist indicates an expected call of Persist.
func (mr *MockPersisterMockRecorder) Persist(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Persist", reflect.TypeOf((*MockPersister)(nil).Persist), arg0, arg1)
}

// RPop mocks base method.
func (m *MockPersister) RPop(arg0 context.Context, arg1 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPop", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RPop indicates an expected call of RPop.
func (mr *MockPersisterMockRecorder) RPop(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPop", reflect.TypeOf((*MockPersister)(nil).RPop), arg0, arg1)
}

// RPush mocks base method.
func (m *MockPersister) RPush(arg0 context.Context, arg1 []byte, arg2 ...[]byte) int64 {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RPush", varargs...)
	ret0, _ := ret[0].(int64)
	return ret0
}

// RPush indicates an expected call of RPush.
func (mr *MockPersisterMockRecorder) RPush(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPush", reflect.TypeOf((*MockPersister)(nil).RPush), varargs...)
}

// Set mocks base method.
func (m *MockPersister) Set(arg0 context.Context, arg1, arg2 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockPersisterMockRecorder) Set(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockPersister)(nil).Set), arg0, arg1, arg2)
}

// TTL mocks base method.
func (m *MockPersister) TTL(arg0 context.Context, arg1 []byte) uint32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TTL", arg0, arg1)
	ret0, _ := ret[0].(uint32)
	return ret0
}

// TTL indicates an expected call of TTL.
func (mr *MockPersisterMockRecorder) TTL(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TTL", reflect.TypeOf((*MockPersister)(nil).TTL), arg0, arg1)
}

// MockDispatcher is a mock of Dispatcher interface.
type MockDispatcher struct {
	ctrl     *gomock.Controller
	recorder *MockDispatcherMockRecorder
	isgomock struct{}
}

// MockDispatcherMockRecorder is the mock recorder for MockDispatcher.
type MockDispatcherMockRecorder struct {
	mock *MockDispatcher
}

// NewMockDispatcher creates a new mock instance.
func NewMockDispatcher(ctrl *gomock.Controller) *MockDispatcher {
	mock := &MockDispatcher{ctrl: ctrl}
	mock.recorder = &MockDispatcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDispatcher) EXPECT() *MockDispatcherMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockDispatcher) Apply(ctx context.Context, args domain.Args) domain.Results {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", ctx, args)
	ret0, _ := ret[0].(domain.Results)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockDispatcherMockRecorder) Apply(ctx, args any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockDispatcher)(nil).Apply), ctx, args)
}

// Clear mocks base method.
func (m *MockDispatcher) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockDispatcherMockRecorder) Clear() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockDispatcher)(nil).Clear))
}

// MockLogicaler is a mock of Logicaler interface.
type MockLogicaler struct {
	ctrl     *gomock.Controller
	recorder *MockLogicalerMockRecorder
	isgomock struct{}
}

// MockLogicalerMockRecorder is the mock recorder for MockLogicaler.
type MockLogicalerMockRecorder struct {
	mock *MockLogicaler
}

// NewMockLogicaler creates a new mock instance.
func NewMockLogicaler(ctrl *gomock.Controller) *MockLogicaler {
	mock := &MockLogicaler{ctrl: ctrl}
	mock.recorder = &MockLogicalerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogicaler) EXPECT() *MockLogicalerMockRecorder {
	return m.recorder
}

// Free mocks base method.
func (m *MockLogicaler) Free(handler domain.Dispatcher) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Free", handler)
}

// Free indicates an expected call of Free.
func (mr *MockLogicalerMockRecorder) Free(handler any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Free", reflect.TypeOf((*MockLogicaler)(nil).Free), handler)
}

// Get mocks base method.
func (m *MockLogicaler) Get(ctx context.Context) domain.Dispatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx)
	ret0, _ := ret[0].(domain.Dispatcher)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockLogicalerMockRecorder) Get(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockLogicaler)(nil).Get), ctx)
}
